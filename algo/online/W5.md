# W5: Online Makespan Minimalization (Real time)

## Problem

输入 $n$ 个时长为 $p_i$, 在 $r_i$ 时刻, 我们才收到这个任务. 显然, 你不能在 $r_i$ 时刻之前开始处理这个任务 (即使是 $\text{OPT}$ 的算法也不能).

## Some attempts

先尝试使用 greedy. Greedy 的做法显然就是每次接到一个任务, 类似之前, 调度当最早空闲的机器.

当然, 假设你当前接收到了 $p_i$, 但是你没有空闲的机器, 你肯定会等到有机器空闲了再 schedule. 在这个过程中, 可能你会收到更多的任务. 因此, 在机器空闲出来之后, 你可能已经收到了多个任务.

整体思路就是机器空闲的时候, 就从已有的任务队列里面挑一个时间最长的任务来做.

一定有 $\text{ALG} \le 1.5 \text{OPT}$.

对所有的不等待立刻发射的算法, competitive ratio 至少是 $1.5$.

举例: 在 $0$ 时刻发射 $m$ 个 $1$, 在 $0 + \epsilon$ 时刻发射 $1$ 个 $2$. 此时, 任何无等待的算法得到 $3$, 但是 $\text{OPT}$ 得到 $2 + \epsilon$.

### Proof

证明 1.5 是一个 bound.

首先, 假设一个任务真实启动时间是 $s_i$, 那么在 $r_i$ 到 $s_i$ 之间, 没有机器是空闲的 (否则会 greedy 去填空).
