# T1

## About CHATGPT

First, I'm sorry to say that CHATGPT is BS-ing. The counter example comes as follows:

Conside $p = \{1,2,3,4\}$. On first day, the min-heap contains $\{1\}$. On the second day, since $1 \lt 2$, the algorithm pops $1$ from min-heap and insert $2$, claim to have a gain of $1$. Then, on the third day, similar things happens ($3$ pops $2$, claiming gain as $1$). So is the fourth day. After the fourth day, we have only $\{4\}$ in the min-heap. The total gain is $1 + 1 + 1 = 3$.

However, we can do it better. We can buy stock on day $1 , 2$ and sell on day $3$ and $4$. The total gain is $3 + 4 - 1 - 2 = 4$. So the algorithm is not optimal.

> REMARK: The problem of this algorithm is that it doesn't reconsider the element which pops out of the min-heap at all. Some of those elements have poped out other elements to be in the min-heap, so when they are poped, they might be reused some time later.

## My solution

### Dynamic programming

Let $f(i, j)$ be the maximum gain we can get from the first $i$ days with $j$ stocks in hand. Then we have the following recursive formula:

$$
\begin{aligned}
f(i, j) &= \max \{ f(i - 1, j), f(i - 1, j - 1) - p_i ,f(i - 1, j + 1) + p_i \} (j \gt 0) \\
f(i, 0) &= \max \{ f(i - 1, 0), f(i - 1, 1) + p_i \}
\end{aligned}
$$

Specially, we have $f(0, 0) = 0$ and other $f(0, j) = -\infty$.

This trivially holds true, and the time complexity is $O(n^2)$.

### An improved solution of CHATGPT

The chatgpt is already doing a good job, except it fails to reconsider some elements. We improve it as follows:

- Enumerate the days from $1$ to $n$.

- If the min-heap is empty, insert the stock price of the day.

- If the min-heap is not empty, compare the smallest element $p_j$ in the min-heap with the stock price $p_i$ of the day.

    + If $p_j \ge p_i$, insert $p_i$ into the min-heap.

    + If $p_j \lt p_i$, insert $p_i$ into the min-heap and mark $i$ as sold-out. Then checking $j$.

        * If $j$ is marked as sold-out, just reset $j$ as not sold-out, and keep it in the min-heap.

        * Otherwise, pop $j$ from the min-heap. $j$ will never be used again. We mark it as buy-out.

The only difference is that for those "sold-out" elements, if they are cheaper than the current stock price, they will not be poped out, but just reset to be not sold-out.

It's obivious that the time complexity is $O(n \log n)$ (since we only insert and pop elements from the min-heap).

The hardest part is to prove the correctness of this algorithm.

#### Notations

Without loss of generality, we assume that the stock prices are distinct.

First, we introduce some notations:

- Choice $c$, where $c_i = \{-1, 0, 1\}$, means the choice of the $i$-th day. $-1$ means sell, $0$ means do nothing, and $1$ means buy.

- $s_i = \sum_{k=1}^i c_k$ is the number of stocks in hand after the $i$-th day. A valid choice must ensure that $s_i \ge 0$ for all $i$.

- If $s_i = 0$, we call day $i$ a zero-stock day.

- Special function $z(i,j)$. If there exists a zero-stock day $k \in [i, j - 1]$, then $z(i,j) = 1$. Otherwise, $z(i,j) = 0$.

- Profit $P(c) = \sum_{i=1}^n -c_i p_i$ is the profit of the choice $c$. This holds true by definition.

#### Observations

We have some intuitive observations:

1. If $\exists i,j, p_i\lt p_j, i \lt j, c_i \in \{-1,0\}, c_j \in \{0,1\}$, then $c$ is not optimal.
2. If $\exists i,j, p_i\gt p_j, i \lt j, c_i \in \{0,1\}, c_j \in \{-1,0\}, z(i,j) = 0$, then $c$ is not optimal.
3. If $c(n) = 1$, then $c$ is not optimal.

If $1$ happens, we can improve $c$ by letting $c' = c$ except that ${c_i}' = c_i + 1$ and ${c_j}' = c_j - 1$. The profit of $c'$ is $P(c') = P(c) - p_i + p_j \gt P(c)$. In addition, the validity of $c'$ is guaranteed since this operation will only make ${s_x}'$ no less than ${s_x}$, where $x \in [1,n]$. So $c'$ is a better choice than $c$. $c$ is not optimal.

$2$ is similar to $1$, except that ${s_x}' = s_x - 1$ for those $x \in [i,j - 1]$, while other $s_x$ remains the same. The validity is challenged, but with the additional condition that $z(i,j) = 0$, which means all ${s_x} \ge 1$ for $x \in [i,j - 1]$. So ${s_x}' \ge 0$ for all $x \in [1,n]$. The validity is guaranteed. So $c$ is not optimal.

$3$ is also trivial, since we may cancel the last buy operation.

We call a choice $c$ a "perfect" choice if it doesn't have those three conditions. We have proved that if a choice is optimal, then it must be a "perfect" choice.

#### Induction

Then, we are going to prove that there's only one "perfect" choice, which is the choice generated by the algorithm.

This trivially holds true for $n = 1$. We assume that it holds true for $n = k$. Then we consider $n = k + 1$.

Suppose $c$ is one of the "perfect" choices for $n = k + 1$

- $c_{k + 1} = 1$, impossible. We will not mark the last day buy-out.

- $c_{k + 1} = 0$. So, $s_k = s_{k + 1} - c_{k + 1} = 0 - 0 = 0$, which means $c$ is also a (and the only one due to the induction hypothesis) "perfect" choice for $n = k$, which is the previous state of our algorithm. Based on the condition $1$, $\forall i \in [1,k], (p_i \ge p_{k+1} \bigvee c_i = 1)$. Since those buy-out days are out of the heap, all those in-heap elements (all non-buy-out element) are no less than $p_{k+1}$. So, our algorithm will just find out the right buy-out days, finding out the right $c$ choice.

- $c_{k + 1} = -1$. Let $m$ be the last zero-stock day before $k + 1$ (we allow $m$ to be $0$). Suppose $x$ is the most costly stock during $[m + 1, k]$ where $c_x \in \{0,1\}$. We construct $c'$ be choice for $n$ which is almost the same as $c$ except that ${c_x}' = {c_x} - 1$. It's easy and routine to verify that $c'$ is also a valid "perfect" choice. Due to our induction hypothesis, $c'$ is the output of our algorithm for $n = k$. And in this case, since $c$ is a "perfect" choice, due to the condition $1$, all the in-heap (non-buy-out) elements before $x$ must be greater than $p_{x}$. Due to condition $2$, so is all elements after $x$ (we utilize the fact that $m$ is the last zero-stock day and $x$ is after $m$, so $z(x,k+1) = 0$). So in $c'$, $x$ is the cheapest stock in-heap, and with the fact that all elements after $x$ is greater than $p_x$, $p_{k+1}$ should be greater than $p_x$. So, our algorithm will try to use $k+1$ to replace $x$. If $x$ is marked as sold-out (${c_x}' = -1$), then $x$ will be reset from sold-out (${c_x} = 0$). If $x$ is not marked as sold-out(${c_x} = 0$), then $x$ will be poped out (${c_x} = -1$). So, in both cases, $c'$ is the output of our algorithm for $n = k + 1$. So, $c$ is the output of our algorithm for $n = k + 1$.

In summary, for all cases, $c$ is the output of our algorithm for $n = k + 1$. 

However, our algorithm is deterministic, so the only "perfect" choice is the output of our algorithm.

Also, we have proved that any best choice must be a "perfect" choice, but the output of our algorithm is the only "perfect" choice. So the output of our algorithm is the only best choice (based on our assumption that the stock prices are distinct).

If stock prices are not distinct, the proof process is similar, and it's too long to write again here...

### Some comments

The core algorithm only took me about $10 \text{min}$. It is easy to be observed with the hint of the given CHATGPT algorithm. However, the correctness of this algorithm is lunatic to prove. I even write a small program to verify the correctness of this algorithm. It did pass all the sample tests. But I still could not prove it out.

The final idea caught me after three hell-like hours. Are you serious?

# T2

If the carry process of an addition happens $x$ times in the addition process of $y + 1$, then it's trivial to see that the lowest $x$ bits of $y$ are all $1$, and the $(x+1)$-th bit is $0$. After the addition, the lowest $x$ bits of $y$ are all $0$, and the $(x+1)$-th bit is $1$, while the higher bits are unchanged. So there are exactly $x + 1$ bits (the lowest $x+1$ bits) flipped when we add $1$ to $y$, which indicates the addition cost is $x + 1$ operation.

If we define $C(y)$ as the number of bits of $y$ that are $1$, then it's trivial to see that $C(y + 1) = C(y) + 1 - x$ (due to the fact that $1$ bit is flipped to $1$ and $x$ bits are flipped to $0$). It means that $\Delta C = 1 - x$.

So we may let the potential function be $f(y) = C(y)$. The cost of an operation is $x + 1 = 2 - \Delta C$. Also, the potential function is always non-negative, and can grow at most $1$ in each operation. So we can claim that the amortized cost is $O(1)$ using the potential function $f(y) = C(y)$.

# T3


# T4

Time distribution (Thinking + Writing):

- T1: $180\text{min} + 30\text{min}$

- T2: $5\text{min} + 5\text{min}$

- T3:

Difficulty: $5/5$.

Comment: Very hard greedy problem. Make my brain spin.
